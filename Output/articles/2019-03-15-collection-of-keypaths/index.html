<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="An Unheralded Perspective"/><link rel="canonical" href="https://siddarthkalra.github.io/articles/2019-03-15-collection-of-keypaths"/><meta name="twitter:url" content="https://siddarthkalra.github.io/articles/2019-03-15-collection-of-keypaths"/><meta name="og:url" content="https://siddarthkalra.github.io/articles/2019-03-15-collection-of-keypaths"/><title>A collection of key paths, same root type but different values | An Unheralded Perspective</title><meta name="twitter:title" content="A collection of key paths, same root type but different values | An Unheralded Perspective"/><meta name="og:title" content="A collection of key paths, same root type but different values | An Unheralded Perspective"/><meta name="description" content="I love Swift KeyPaths as they allow us to work in a type-safe environment. But I ran into a problem the other day when using them for a feature I was implementing."/><meta name="twitter:description" content="I love Swift KeyPaths as they allow us to work in a type-safe environment. But I ran into a problem the other day when using them for a feature I was implementing."/><meta name="og:description" content="I love Swift KeyPaths as they allow us to work in a type-safe environment. But I ran into a problem the other day when using them for a feature I was implementing."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to An Unheralded Perspective"/></head><body class="item-page"><header><div class="wrapper"><a class="site-name" href="/">An Unheralded Perspective</a><nav><ul><li><a class="selected" href="/articles">Articles</a></li><li><a href="/about">About</a></li></ul></nav></div></header><div class="wrapper"><article><div class="content"><p>I love Swift <a href="https://developer.apple.com/documentation/swift/keypath"><code>KeyPaths</code></a> as they allow us to work in a type-safe environment. But I ran into a problem the other day when using them for a feature I was implementing.</p><p>I wanted the ability to create an array of <code>KeyPaths</code> where the <code>Root</code> was the same type but the <code>Value</code> types were different. The first thing I tried was this:</p><pre><code><span class="splash-keyword">class</span> Dog {
    <span class="splash-keyword">@objc let</span> name: <span class="splash-type">String</span> = <span class="splash-string">""</span>
    <span class="splash-keyword">@objc let</span> age: <span class="splash-type">Int</span> = <span class="splash-number">0</span>
}

<span class="splash-keyword">let</span> keyPaths = [\<span class="splash-type">Dog</span>.<span class="splash-property">name</span>, \<span class="splash-type">Dog</span>.<span class="splash-property">age</span>]
</code></pre><p>Xcode reports that <code>keyPaths</code> has the type <code>PartialKeyPath&lt;Dog&gt;</code>. This actually makes sense because <code>name</code> is a <code>String</code> while <code>age</code> is an <code>Int</code>. So, Swift uses a <a href="https://developer.apple.com/documentation/swift/partialkeypath"><code>PartialKeyPath</code></a>, which type-erases the <code>Values</code> for you.</p><p>This was great but didn't work for my particular problem. I wanted to use <code>KeyPaths</code> to represent property names in a type-safe manner. Given a <code>KeyPath</code>, print out the property name of the value, like so:</p><pre><code><span class="splash-keyword">func</span> printPropertyName&lt;Root, Value&gt;(keyPath: <span class="splash-type">KeyPath</span>&lt;<span class="splash-type">Root</span>, <span class="splash-type">Value</span>&gt;) {
    <span class="splash-keyword">let</span> propertyName = <span class="splash-type">NSExpression</span>(forKeyPath: keyPath).<span class="splash-property">keyPath</span>
    <span class="splash-call">print</span>(propertyName)
}

<span class="splash-call">printPropertyName</span>(keyPath: \<span class="splash-type">Dog</span>.<span class="splash-property">name</span>) <span class="splash-comment">// prints name</span>
<span class="splash-call">printPropertyName</span>(keyPath: \<span class="splash-type">Dog</span>.<span class="splash-property">age</span>) <span class="splash-comment">// prints age</span>
</code></pre><p><code>NSExpression</code> is a great Apple API that gives us the ability to retrieve the property name of a <code>KeyPath</code>, if the property is annotated with <code>@objc</code>.</p><p>Next, I wanted the ability to pass in a collection of <code>KeyPaths</code> like so:</p><pre><code><span class="splash-call">printPropertyNames</span>(keyPaths: [\<span class="splash-type">Dog</span>.<span class="splash-property">name</span>, \<span class="splash-type">Dog</span>.<span class="splash-property">age</span>])
</code></pre><p>As we saw earlier, the type of the array would be <code>PartialKeyPath&lt;Dog&gt;</code>. Unfortunately, since the <code>KeyPath's</code> <code>Value</code> is type-erased, we loose the ability to retrieve the property names and <code>NSExpression()</code> no longer works for us.</p><pre><code><span class="splash-keyword">func</span> printPropertyNames&lt;Root&gt;(keyPaths: [<span class="splash-type">PartialKeyPath</span>&lt;<span class="splash-type">Root</span>&gt;]) {
    keyPaths.<span class="splash-call">forEach</span> { keyPath <span class="splash-keyword">in
        let</span> valueName = <span class="splash-type">NSExpression</span>(forKeyPath: keyPath).<span class="splash-property">keyPath</span>
        <span class="splash-call">print</span>(valueName)
    }
}

<span class="splash-call">printPropertyNames</span>(keyPaths: [\<span class="splash-type">Dog</span>.<span class="splash-property">name</span>, \<span class="splash-type">Dog</span>.<span class="splash-property">age</span>])
</code></pre><p>The compiler tells us we're crazy by throwing an error <code>Cannot invoke initializer for type 'NSExpression' with an argument list of type '(forKeyPath: (PartialKeyPath&lt;Root&gt;))'</code> for the code shown above.</p><p>So, how do we get around this problem? Well, one approach is to wrap our <code>KeyPath</code> access in a closure.</p><p>Let's start by defining a function that makes this wrapping closure for us. We'll refer to the closure as a <code>PropertyRef</code>:</p><pre><code><span class="splash-keyword">typealias</span> PropertyName = <span class="splash-type">String</span>

<span class="splash-keyword">func</span> makePropertyRef&lt;Root, Value&gt;(keyPath: <span class="splash-type">KeyPath</span>&lt;<span class="splash-type">Root</span>, <span class="splash-type">Value</span>&gt;) -&gt; (<span class="splash-type">Root</span>.<span class="splash-type">Type</span>) -&gt; <span class="splash-type">PropertyName</span> {
    <span class="splash-keyword">return</span> { rootType <span class="splash-keyword">in
        let</span> propertyName = <span class="splash-type">NSExpression</span>(forKeyPath: keyPath).<span class="splash-property">keyPath</span>
        <span class="splash-keyword">return</span> propertyName
    }
}
</code></pre><p>Now, given a <code>KeyPath</code>, we can make a <code>PropertyRef</code>. All that remains is to rewrite our print property name function to work with <code>PropertyRefs</code> instead of <code>KeyPaths</code>:</p><pre><code><span class="splash-keyword">func</span> printPropertyNames&lt;Root&gt;(propertyRefs: (<span class="splash-type">Root</span>.<span class="splash-type">Type</span>) -&gt; <span class="splash-type">PropertyName</span>...) {
    <span class="splash-keyword">let</span> propertyNames = propertyRefs.<span class="splash-call">map</span> { $0(<span class="splash-type">Root</span>.<span class="splash-keyword">self</span>) }
    <span class="splash-call">print</span>(propertyNames)
}

<span class="splash-call">printPropertyNames</span>(propertyRefs: <span class="splash-call">makePropertyRef</span>(keyPath: \<span class="splash-type">Dog</span>.<span class="splash-property">name</span>), <span class="splash-call">makePropertyRef</span>(keyPath: \<span class="splash-type">Dog</span>.<span class="splash-property">age</span>))
</code></pre><p>This is great because we retain the type-safety that KeyPaths give us and it stops us from mixing <code>Root</code> types, which is exactly what we want.</p><pre><code><span class="splash-call">printPropertyNames</span>(propertyRefs: <span class="splash-call">makePropertyRef</span>(keyPath: \<span class="splash-type">Dog</span>.<span class="splash-property">breed</span>)) <span class="splash-comment">// compiler error</span>
<span class="splash-call">printPropertyNames</span>(propertyRefs: <span class="splash-call">makePropertyRef</span>(keyPath: \<span class="splash-type">Dog</span>.<span class="splash-property">name</span>), <span class="splash-call">makePropertyRef</span>(keyPath: \<span class="splash-type">Cat</span>.<span class="splash-property">age</span>)) <span class="splash-comment">// compiler error</span>
</code></pre><p>So, there you have it. We now have the ability to produce a collection of <code>KeyPaths</code> where our <code>Root</code> is the same but the values are different while retaining our ability to access the property names of the <code>Values</code>.</p></div><span>Tags: </span><ul class="tag-list"><li class="tag tag-a"><a href="/tags/article">article</a></li><li class="tag tag-e"><a href="/tags/swift">swift</a></li><li class="tag tag-d"><a href="/tags/key-paths">key paths</a></li></ul></article></div><footer><p>An Unheralded Perspective © 2020 ⋅ All rights reserved</p><p>Built in Swift using <a href="https://github.com/johnsundell/publish" target="_blank">Publish</a></p><p><a href="https://twitter.com/siddarthkalra" target="_blank">Twitter</a> | <a href="/feed.rss" target="_blank">RSS</a></p></footer></body></html>