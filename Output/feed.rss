<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>An Unheralded Perspective</title><description>My thoughts on Swift, iOS development and beyond</description><link>https://siddarthkalra.github.io</link><language>en</language><lastBuildDate>Wed, 16 Dec 2020 16:31:33 -0500</lastBuildDate><pubDate>Wed, 16 Dec 2020 16:31:33 -0500</pubDate><ttl>250</ttl><atom:link href="https://siddarthkalra.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://siddarthkalra.github.io/posts/2019-04-19-uncaught-exceptions-macos</guid><title>Uncaught exceptions on macOS</title><description>I recently came across a peculiar distinction between how exceptions manifest on macOS vs. iOS. On iOS, if an NSRangeException (index out of bounds) occurs, your app will crash, no questions asked. However, that is not always the case on macOS</description><link>https://siddarthkalra.github.io/posts/2019-04-19-uncaught-exceptions-macos</link><pubDate>Fri, 19 Apr 2019 18:45:00 -0400</pubDate><content:encoded><![CDATA[<p>I recently came across a peculiar distinction between how exceptions manifest on macOS vs. iOS.</p><p>On iOS, if an <code>NSRangeException</code> (index out of bounds) occurs, your app will crash, no questions asked. However, that is not always the case on macOS. This behaviour doesn't seem to be that widely known and I had to go digging quite a bit to uncover its roots.</p><p>On macOS, exceptions that go unhandled will rise to the level of the uncaught exception handler. This is the point where one can perform extra logic before the program exits. The default handler logs the exception to the console before exiting.</p><p>However, the key point is that exceptions on the main thread don't rise to the level of the uncaught exception handler as the global application object catches them preemptively. This is why certain exceptions don't lead to a crash on macOS. Apple details this behaviour <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Exceptions/Concepts/UncaughtExceptions.html">here</a>.</p><p>If your app is using a crash reporting tool like <a href="https://Sentry.io">Sentry</a> or <a href="https://firebase.google.com/docs/crashlytics/">Crashlytics</a>, you don't want to silently log exceptions to the console. You want to know about them. So, how do we handle these exceptions?</p><p>We can subclass <code>NSApplication</code> and override the <code>reportException(_:)</code> method to provide our own custom behaviour:</p><pre><code><span class="splash-keyword">@objc</span>(<span class="splash-type">CustomExceptionHandlingApp</span>)
<span class="splash-keyword">class</span> CustomExceptionHandlingApp: <span class="splash-type">NSApplication</span> {

    <span class="splash-keyword">override func</span> reportException(<span class="splash-keyword">_</span> exception: <span class="splash-type">NSException</span>) {
        <span class="splash-type">UserDefaults</span>.<span class="splash-property">standard</span>.<span class="splash-call">register</span>(defaults: [<span class="splash-string">"NSApplicationCrashOnExceptions"</span>: <span class="splash-keyword">true</span>])

        <span class="splash-comment">// custom code to handle the exception here</span>

        <span class="splash-keyword">super</span>.<span class="splash-call">reportException</span>(exception)
    }

}
</code></pre><p>After creating the subclass, make sure to update the <code>NSPrincipalClass</code> key in your app's Info.plist to the name of the subclass instead of <code>NSApplication</code>.</p><p>The last thing to note is that if you want your application to exit when an exception occurs then set the <code>NSApplicationCrashOnExceptions</code> key to <code>true</code>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://siddarthkalra.github.io/posts/2019-04-06-side-effects</guid><title>Side effects</title><description>Side effects can have deadly consequences. We all pay attention to them when picking up a pack of antibiotics from the pharmacist. But are you paying attention to them when writing your next app feature?</description><link>https://siddarthkalra.github.io/posts/2019-04-06-side-effects</link><pubDate>Sat, 6 Apr 2019 18:45:00 -0400</pubDate><content:encoded><![CDATA[<p>Side effects can have deadly consequences. We all pay attention to them when picking up a pack of antibiotics from the pharmacist. But are you paying attention to them when writing your next app feature? If you haven't been, I'm here to convince you that it's worth reading the fine-print and avoiding them whenever possible.</p><img src="https://siddarthkalra.github.io/images/side-effects.jpg" alt="Side Effects meme"/><p>So, let's start by defining our terms. Side effects, in the realm of programming, are hidden consequences or changes. That is, when calling a function leads to something being accessed or changed outside the scope of that function. The function can then no longer be considered <a href="https://en.wikipedia.org/wiki/Pure_function">pure</a>. Here is an example of a pure function:</p><pre><code><span class="splash-keyword">func</span> multiplyBy2(<span class="splash-keyword">_</span> value: <span class="splash-type">Int</span>) -&gt; <span class="splash-type">Int</span> {
    <span class="splash-keyword">return</span> value * <span class="splash-number">2</span>
}
</code></pre><p>We usually want to aim for pure functions whenever possible because they allow us to locally reason about our program as there is no global impact upon invocation. Introducing side effects means that we may no longer be able to reason locally as changes at the global scope can be introduced. This increases the complexity of our program.</p><p>Today we're going to discuss two types of side effects: <strong>hidden inputs</strong> and <strong>hidden outputs</strong>. As a general rule, hidden changes are something that you want to avoid. Having implicit changes can make your API unclear and unobvious, which can lead to misuse and unintended results. Now that we've covered what side effects are, let's examine each flavor in detail.</p><p>Say, I'm writing a chat messaging app to break the dominance of WhatsApp in the market. That's going to be tough, so let's ensure that our basics are right first. To do this, I need a way to represent messages in my program. We'll start by defining a data structure that describes the main building block of the app:</p><pre><code><span class="splash-keyword">struct</span> ChatMessage {
    <span class="splash-keyword">let</span> userName: <span class="splash-type">String</span>
    <span class="splash-keyword">let</span> message: <span class="splash-type">String</span>
    <span class="splash-keyword">let</span> creationDate: <span class="splash-type">Date</span>
}
</code></pre><p>Now, I might want to display the chat messages a given user has sent over the last day. For that, I could write a function like so:</p><pre><code><span class="splash-keyword">func</span> getLastDaysChatMessages() -&gt; [<span class="splash-type">ChatMessage</span>]? {
  <span class="splash-keyword">guard let</span> rawChatMessages =
      <span class="splash-type">UserDefaults</span>.<span class="splash-property">standard</span>.<span class="splash-call">array</span>(forKey: <span class="splash-string">"chatMessages"</span>) <span class="splash-keyword">as</span>? [<span class="splash-type">RawChatMessage</span>] <span class="splash-keyword">else</span> { <span class="splash-keyword">return nil</span> }

  <span class="splash-keyword">let</span> yesterday = <span class="splash-type">Calendar</span>.<span class="splash-property">current</span>.<span class="splash-call">date</span>(byAdding: .<span class="splash-dotAccess">day</span>,
                                        value: -<span class="splash-number">1</span>,
                                        to: <span class="splash-type">Date</span>())!

    <span class="splash-keyword">return</span> rawChatMessages
        .<span class="splash-call">compactMap</span>(transformDictToChatMessage)
        .<span class="splash-call">filter</span> { $0.<span class="splash-property">creationDate</span> &gt; yesterday }
}
</code></pre><p>Even though this function gets the job done, we have a few problems. We've come across our first type of side effect. <code>UserDefaults.standard</code>, <code>Calendar.current</code> and <code>Date()</code> are all <strong>hidden inputs</strong>. <code>UserDefaults.standard</code> and <code>Calendar.current</code> are both singletons that can be altered by other parts of our program at any time. Also, since we only get the date at the time of invocation, this function will not produce predictable results if invoked multiple times, which reduces testability.</p><p>Let's see if we can restore predicability and remove outside influence to restore our ability to locally reason about this piece of code:</p><pre><code><span class="splash-keyword">func</span> getChatMessages(rawChatMessages: [<span class="splash-type">RawChatMessage</span>], filter: (<span class="splash-type">ChatMessage</span>) -&gt; <span class="splash-type">Bool</span>) -&gt; [<span class="splash-type">ChatMessage</span>] {
    <span class="splash-keyword">return</span> rawChatMessages
        .<span class="splash-call">compactMap</span>(transformDictToChatMessage)
        .<span class="splash-call">filter</span>(filter)
}

<span class="splash-comment">// Usage</span>
<span class="splash-keyword">let</span> yesterday = <span class="splash-type">Calendar</span>.<span class="splash-property">current</span>.<span class="splash-call">date</span>(byAdding: .<span class="splash-dotAccess">day</span>, value: -<span class="splash-number">1</span>, to: <span class="splash-type">Date</span>())!

<span class="splash-call">getChatMessages</span>(rawChatMessages: rawChatMessages,
                filter: { $0.<span class="splash-property">creationDate</span> &gt; yesterday })
</code></pre><p>In our above solution, we've leveraged dependency injection to remove <code>UserDefaults.standard</code> and <code>Calendar.current</code> from the equation altogether. Our function no longer cares about these concepts, which makes tests much easier to write. We've also added the <code>filter</code> parameter. Now a date can be injected. This will allow us to get predictable results when the function is invoked multiple times as the date will not change during each invocation.</p><p>Now that we have a clean way to retrieve chat messages, what about saving new ones? Let's start by taking the following approach:</p><pre><code><span class="splash-keyword">func</span> saveChatMessages(<span class="splash-keyword">_</span> chatMessages: [<span class="splash-type">ChatMessage</span>]) {
    chatMessages.<span class="splash-call">forEach</span> {
        <span class="splash-type">AnalyticsManager</span>.<span class="splash-property">shared</span>.<span class="splash-call">recordChatMessage</span>($0)
    }

    <span class="splash-keyword">let</span> rawChatMessages = chatMessages.<span class="splash-call">map</span>(transformChatMessageToDict)
    <span class="splash-type">UserDefaults</span>.<span class="splash-property">standard</span>.<span class="splash-call">set</span>(rawChatMessages, forKey: <span class="splash-string">"chatMessages"</span>)
}
</code></pre><p>So, here we have an <code>AnalyticsManager</code> recording some information. Maybe we're interested in tracking which of our users are the most active or which topics users are discussing on a given day. We're also persisting our chat messages to user defaults.</p><p>There's a lot going on here. Both <code>AnalyticsManager</code> and <code>UserDefaults</code> are reaching out to the outside world and making some sort of change. They are both examples of <strong>hidden outputs</strong>. Testing this function is going to take a bit of work. We can do better by breaking things apart.</p><pre><code><span class="splash-keyword">typealias</span> ProcessMessage = (<span class="splash-type">ChatMessage</span>) -&gt; <span class="splash-type">Void</span>

<span class="splash-keyword">func</span> saveChatMessages(<span class="splash-keyword">_</span> chatMessages: [<span class="splash-type">ChatMessage</span>], processMessage: <span class="splash-type">ProcessMessage</span>?) -&gt; [<span class="splash-type">RawChatMessage</span>] {
    <span class="splash-keyword">if let</span> processMessage = processMessage {
        chatMessages.<span class="splash-call">forEach</span>(processMessage)
    }

    <span class="splash-keyword">return</span> chatMessages.<span class="splash-call">map</span>(transformChatMessageToDict)
}
</code></pre><p>In this incarnation of our function, <code>AnalyticsManager</code> and <code>UserDefaults</code> are nowhere to be found so our tests don't have to worry about them. But we can still use both these classes in our app code. <code>AnalyticsManager</code> can be injected via the <code>processMessage</code> closure that can be optionally provided as a function parameter and we can process the raw chat messages and save them to <code>UserDefaults</code> by using the array returned by the function.</p><p>Side effects are quite common in many codebases. Our goal should always be to define a clear API and ensure that testing is not cumbersome. This is easier to do if we limit the side effects in our code. Introducing stronger forms of decoupling and ensuring that our functions are following the principal of <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">single responsibility</a> can go a long way in limiting the amount of side effects we have to live with.</p><p>Have you come across other types of side effects in your code? If so, let me know on Twitter <a href="https://twitter.com/siddarthkalra">@siddarthkalra</a>. All other forms of feedback are welcome as well. Have a great day and props to you for reading till the end!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://siddarthkalra.github.io/posts/2019-03-15-collection-of-keypaths</guid><title>A collection of key paths, same root type but different values</title><description>I love Swift KeyPaths as they allow us to work in a type-safe environment. But I ran into a problem the other day when using them for a feature I was implementing.</description><link>https://siddarthkalra.github.io/posts/2019-03-15-collection-of-keypaths</link><pubDate>Fri, 15 Mar 2019 10:18:00 -0400</pubDate><content:encoded><![CDATA[<p>I love Swift <a href="https://developer.apple.com/documentation/swift/keypath"><code>KeyPaths</code></a> as they allow us to work in a type-safe environment. But I ran into a problem the other day when using them for a feature I was implementing.</p><p>I wanted the ability to create an array of <code>KeyPaths</code> where the <code>Root</code> was the same type but the <code>Value</code> types were different. The first thing I tried was this:</p><pre><code><span class="splash-keyword">class</span> Dog {
    <span class="splash-keyword">@objc let</span> name: <span class="splash-type">String</span> = <span class="splash-string">""</span>
    <span class="splash-keyword">@objc let</span> age: <span class="splash-type">Int</span> = <span class="splash-number">0</span>
}

<span class="splash-keyword">let</span> keyPaths = [\<span class="splash-type">Dog</span>.<span class="splash-property">name</span>, \<span class="splash-type">Dog</span>.<span class="splash-property">age</span>]
</code></pre><p>Xcode reports that <code>keyPaths</code> has the type <code>PartialKeyPath&lt;Dog&gt;</code>. This actually makes sense because <code>name</code> is a <code>String</code> while <code>age</code> is an <code>Int</code>. So, Swift uses a <a href="https://developer.apple.com/documentation/swift/partialkeypath"><code>PartialKeyPath</code></a>, which type-erases the <code>Values</code> for you.</p><p>This was great but didn't work for my particular problem. I wanted to use <code>KeyPaths</code> to represent property names in a type-safe manner. Given a <code>KeyPath</code>, print out the property name of the value, like so:</p><pre><code><span class="splash-keyword">func</span> printPropertyName&lt;Root, Value&gt;(keyPath: <span class="splash-type">KeyPath</span>&lt;<span class="splash-type">Root</span>, <span class="splash-type">Value</span>&gt;) {
    <span class="splash-keyword">let</span> propertyName = <span class="splash-type">NSExpression</span>(forKeyPath: keyPath).<span class="splash-property">keyPath</span>
    <span class="splash-call">print</span>(propertyName)
}

<span class="splash-call">printPropertyName</span>(keyPath: \<span class="splash-type">Dog</span>.<span class="splash-property">name</span>) <span class="splash-comment">// prints name</span>
<span class="splash-call">printPropertyName</span>(keyPath: \<span class="splash-type">Dog</span>.<span class="splash-property">age</span>) <span class="splash-comment">// prints age</span>
</code></pre><p><code>NSExpression</code> is a great Apple API that gives us the ability to retrieve the property name of a <code>KeyPath</code>, if the property is annotated with <code>@objc</code>.</p><p>Next, I wanted the ability to pass in a collection of <code>KeyPaths</code> like so:</p><pre><code><span class="splash-call">printPropertyNames</span>(keyPaths: [\<span class="splash-type">Dog</span>.<span class="splash-property">name</span>, \<span class="splash-type">Dog</span>.<span class="splash-property">age</span>])
</code></pre><p>As we saw earlier, the type of the array would be <code>PartialKeyPath&lt;Dog&gt;</code>. Unfortunately, since the <code>KeyPath's</code> <code>Value</code> is type-erased, we loose the ability to retrieve the property names and <code>NSExpression()</code> no longer works for us.</p><pre><code><span class="splash-keyword">func</span> printPropertyNames&lt;Root&gt;(keyPaths: [<span class="splash-type">PartialKeyPath</span>&lt;<span class="splash-type">Root</span>&gt;]) {
    keyPaths.<span class="splash-call">forEach</span> { keyPath <span class="splash-keyword">in
        let</span> valueName = <span class="splash-type">NSExpression</span>(forKeyPath: keyPath).<span class="splash-property">keyPath</span>
        <span class="splash-call">print</span>(valueName)
    }
}

<span class="splash-call">printPropertyNames</span>(keyPaths: [\<span class="splash-type">Dog</span>.<span class="splash-property">name</span>, \<span class="splash-type">Dog</span>.<span class="splash-property">age</span>])
</code></pre><p>The compiler tells us we're crazy by throwing an error <code>Cannot invoke initializer for type 'NSExpression' with an argument list of type '(forKeyPath: (PartialKeyPath&lt;Root&gt;))'</code> for the code shown above.</p><p>So, how do we get around this problem? Well, one approach is to wrap our <code>KeyPath</code> access in a closure.</p><p>Let's start by defining a function that makes this wrapping closure for us. We'll refer to the closure as a <code>PropertyRef</code>:</p><pre><code><span class="splash-keyword">typealias</span> PropertyName = <span class="splash-type">String</span>

<span class="splash-keyword">func</span> makePropertyRef&lt;Root, Value&gt;(keyPath: <span class="splash-type">KeyPath</span>&lt;<span class="splash-type">Root</span>, <span class="splash-type">Value</span>&gt;) -&gt; (<span class="splash-type">Root</span>.<span class="splash-type">Type</span>) -&gt; <span class="splash-type">PropertyName</span> {
    <span class="splash-keyword">return</span> { rootType <span class="splash-keyword">in
        let</span> propertyName = <span class="splash-type">NSExpression</span>(forKeyPath: keyPath).<span class="splash-property">keyPath</span>
        <span class="splash-keyword">return</span> propertyName
    }
}
</code></pre><p>Now, given a <code>KeyPath</code>, we can make a <code>PropertyRef</code>. All that remains is to rewrite our print property name function to work with <code>PropertyRefs</code> instead of <code>KeyPaths</code>:</p><pre><code><span class="splash-keyword">func</span> printPropertyNames&lt;Root&gt;(propertyRefs: (<span class="splash-type">Root</span>.<span class="splash-type">Type</span>) -&gt; <span class="splash-type">PropertyName</span>...) {
    <span class="splash-keyword">let</span> propertyNames = propertyRefs.<span class="splash-call">map</span> { $0(<span class="splash-type">Root</span>.<span class="splash-keyword">self</span>) }
    <span class="splash-call">print</span>(propertyNames)
}

<span class="splash-call">printPropertyNames</span>(propertyRefs: <span class="splash-call">makePropertyRef</span>(keyPath: \<span class="splash-type">Dog</span>.<span class="splash-property">name</span>), <span class="splash-call">makePropertyRef</span>(keyPath: \<span class="splash-type">Dog</span>.<span class="splash-property">age</span>))
</code></pre><p>This is great because we retain the type-safety that KeyPaths give us and it stops us from mixing <code>Root</code> types, which is exactly what we want.</p><pre><code><span class="splash-call">printPropertyNames</span>(propertyRefs: <span class="splash-call">makePropertyRef</span>(keyPath: \<span class="splash-type">Dog</span>.<span class="splash-property">breed</span>)) <span class="splash-comment">// compiler error</span>
<span class="splash-call">printPropertyNames</span>(propertyRefs: <span class="splash-call">makePropertyRef</span>(keyPath: \<span class="splash-type">Dog</span>.<span class="splash-property">name</span>), <span class="splash-call">makePropertyRef</span>(keyPath: \<span class="splash-type">Cat</span>.<span class="splash-property">age</span>)) <span class="splash-comment">// compiler error</span>
</code></pre><p>So, there you have it. We now have the ability to produce a collection of <code>KeyPaths</code> where our <code>Root</code> is the same but the values are different while retaining our ability to access the property names of the <code>Values</code>.</p>]]></content:encoded></item></channel></rss>